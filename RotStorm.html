<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rotstorm Generated FPS</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #blocker {
            position: absolute; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6);
            display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 10;
        }
        #instructions {
            text-align: center; background: rgba(0,0,0,0.8); padding: 2.5rem 4rem; border-radius: 12px;
            border: 1px solid #444; cursor: pointer; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        #instructions h1 { margin-top: 0; font-size: 36px; color: #ff4444; text-transform: uppercase; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 5; display: none;
        }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255,255,255,0.9); }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
        #loading { position: absolute; top: 20px; left: 20px; color: white; background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 6px; }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loading">Loading 3D Model...</div>
    <div id="crosshair"></div>
    <div id="blocker">
        <div id="instructions">
            <h1>Rotstorm FPS</h1>
            <p>Click anywhere to start</p>
            <p>W/S: Walk | A/D: Strafe | Space: Jump | Shift: Run | Click: Shoot | R: Reload</p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let camera, scene, renderer, controls;
        let mixer, actions = {};
        let activeAction, previousAction;
        let clock = new THREE.Clock();

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, isRunning = false;
        let isReloading = false, isShooting = false, modelLoaded = false;
        let canJump = false;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.src = 'https://raw.githubusercontent.com/Ren23447/Rotstorm-FPS/refs/heads/main/skyboxRS.jpg';
            img.onload = function() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const tileW = img.width / 4;
                const tileH = img.height / 3;
                canvas.width = tileW;
                canvas.height = tileH;

                const extractFace = (x, y) => {
                    ctx.drawImage(img, x * tileW, y * tileH, tileW, tileH, 0, 0, tileW, tileH);
                    return canvas.toDataURL('image/jpeg', 1.0);
                };

                // Order: px, nx, py, ny, pz, nz
                const faces = [
                    extractFace(2, 1), // Right
                    extractFace(0, 1), // Left
                    extractFace(1, 0), // Top
                    extractFace(1, 2), // Bottom
                    extractFace(1, 1), // Front
                    extractFace(3, 1)  // Back
                ];

                const cubeTexture = new THREE.CubeTextureLoader().load(faces);
                scene.background = cubeTexture;
            };
            
            scene.fog = new THREE.Fog(0x222222, 10, 150);

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            scene.add(new THREE.GridHelper(200, 100, 0x444444, 0x111111));
            
            for(let i=0; i<30; i++) {
                const box = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshStandardMaterial({ color: 0x882222 }));
                box.position.set((Math.random() - 0.5) * 60, 1, (Math.random() - 0.5) * 60);
                scene.add(box);
            }

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.7;

            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            const blocker = document.getElementById('blocker');
            document.getElementById('instructions').addEventListener('click', () => { if (modelLoaded) controls.lock(); });
            controls.addEventListener('lock', () => { blocker.style.display = 'none'; document.getElementById('crosshair').style.display = 'block'; });
            controls.addEventListener('unlock', () => { blocker.style.display = 'flex'; document.getElementById('crosshair').style.display = 'none'; });

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            new GLTFLoader().load('https://raw.githubusercontent.com/Ren23447/Rotstorm-FPS/main/smg_fps_animations.glb', (gltf) => {
                const model = gltf.scene;
                camera.add(model);
                
                model.position.set(-0.01, -0.63, -0.01);
                model.rotation.y = Math.PI;

                mixer = new THREE.AnimationMixer(model);
                const anims = gltf.animations;
                
                const animNames = {"idle":"Rig|KDW_DPose_Idle","walk":"Rig|KDW_Walk","run":"Rig|KDW_Run","shoot":"Rig|KDW_Shot","reload":"Rig|KDW_Reload_fast"};

                for(let key in animNames) {
                    if(animNames[key]) {
                        const clip = anims.find(a => a.name === animNames[key]);
                        if(clip) {
                            actions[key] = mixer.clipAction(clip);
                            if(key === 'shoot' || key === 'reload') {
                                actions[key].setLoop(THREE.LoopOnce, 0);
                                actions[key].clampWhenFinished = true;
                            }
                        }
                    }
                }

                mixer.addEventListener('finished', (e) => {
                    if (e.action === actions['shoot']) { isShooting = false; updateAction(); }
                    if (e.action === actions['reload']) { isReloading = false; updateAction(); }
                });

                if(actions['idle']) fadeToAction('idle', 0);
                
                document.getElementById('loading').style.display = 'none';
                modelLoaded = true;
            });

            document.addEventListener('keydown', (e) => {
                if (!controls.isLocked) return;
                switch (e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space':
                        if (canJump === true) velocity.y += 20.0;
                        canJump = false;
                        break;
                    case 'ShiftLeft': case 'ShiftRight': isRunning = true; break;
                    case 'KeyR':
                        if (!isReloading && !isShooting && actions['reload']) {
                            isReloading = true;
                            actions['reload'].reset();
                            fadeToAction('reload', 0.2);
                        }
                        break;
                }
                updateAction();
            });

            document.addEventListener('keyup', (e) => {
                if (!controls.isLocked) return;
                switch (e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'ShiftLeft': case 'ShiftRight': isRunning = false; break;
                }
                updateAction();
            });

            document.addEventListener('mousedown', (e) => {
                if (!controls.isLocked) return;
                if (e.button === 0 && !isShooting && !isReloading && actions['shoot']) {
                    isShooting = true;
                    actions['shoot'].reset();
                    fadeToAction('shoot', 0.1);
                }
            });
        }

        function updateAction() {
            if (isShooting || isReloading) return;
            let target = 'idle';
            if (moveForward || moveBackward || moveLeft || moveRight) target = isRunning ? 'run' : 'walk';
            if (actions[target] && target !== getActiveActionName()) fadeToAction(target, 0.2);
        }

        function getActiveActionName() {
            for (let key in actions) if (actions[key] === activeAction) return key;
            return null;
        }

        function fadeToAction(name, duration) {
            if (!actions[name]) return;
            previousAction = activeAction;
            activeAction = actions[name];
            if (previousAction && previousAction !== activeAction) previousAction.fadeOut(duration);
            activeAction.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(duration).play();
        }

        const velocity = new THREE.Vector3(), direction = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            if (mixer) mixer.update(dt);

            if (controls.isLocked) {
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                const speed = isRunning ? 50.0 : 25.0;
                
                velocity.x -= velocity.x * 10.0 * dt;
                velocity.z -= velocity.z * 10.0 * dt;
                velocity.y -= 9.8 * 10.0 * dt; // Gravity
                
                if (moveForward || moveBackward) velocity.z -= direction.z * speed * dt;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * dt;

                controls.moveRight(-velocity.x * dt);
                controls.moveForward(-velocity.z * dt);
                
                controls.getObject().position.y += (velocity.y * dt);

                if (controls.getObject().position.y < 1.7) {
                    velocity.y = 0;
                    controls.getObject().position.y = 1.7;
                    canJump = true;
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
